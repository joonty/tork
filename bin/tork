#!/usr/bin/env ruby
=begin =======================================================================

# TORK 1 2012-10-10 18.2.4

## NAME

tork - Continuous testing tool for Ruby

## SYNOPSIS

`tork` [*OPTION*]... [*CONFIG*]...

## DESCRIPTION

This program is a simple command-line user interface for tork-driver(1).  It
loads the given *CONFIG* files (which are either paths to actual files or
names of helper libraries in the tork/config/ namespace of Ruby's load path)
and then waits for you to supply interactive commands either {1} directly on
its stdin or {2} remotely through tork-client(1).  From then onward, you may
press the ENTER key (supplying no command) to see a menu of accepted commands.

## OPTIONS

`-h`, `--help`
  Show this help manual.

## SEE ALSO

tork(1), tork-driver(1), tork-master(1), tork-herald(1), tork-client(1)

=end =========================================================================

$0 = File.basename(__FILE__) # for easier identification in ps(1) output

require 'binman'
BinMan.help

require 'json'
ENV['TORK_CONFIGS'] = JSON.dump(ARGV)

#-----------------------------------------------------------------------------
# backend
#-----------------------------------------------------------------------------

require 'tork/client'

warn "#{$0}: Absorbing test execution overhead..."
@driver = Tork::Client::Transceiver.new('tork-driver') do |event, *details|
  case event_sym = event.to_sym
  when :load then warn "#{$0}: Overhead absorbed. Ready for testing!"
  when :over then warn "#{$0}: Reabsorbing changed overhead files..."
  else
    test_file, line_numbers, log_file, worker_number, exit_status = details
    message = [event.upcase, [test_file, *line_numbers].join(':'),
               exit_status].compact.join(' ')

    color = case event_sym
            when :pass then "\e[34m%s\e[0m" # blue
            when :fail then "\e[31m%s\e[0m" # red
            end
    message = color % message if color and STDOUT.tty?
    message = [message, File.read(log_file), message] if event_sym == :fail

    puts message
  end
end

#-----------------------------------------------------------------------------
# frontend
#-----------------------------------------------------------------------------

COMMANDS = {
  't' => :run_test_file,
  'a' => :run_all_test_files,
  's' => :stop_running_test_files,
  'k' => [:stop_running_test_files, :SIGKILL],
  'p' => :rerun_passed_test_files,
  'f' => :rerun_failed_test_files,
  'o' => :reabsorb_overhead_files,
  'q' => :quit,
}

IO.popen('tork-server') do |input|
  begin
    while line = input.gets
      key, *args = line.split
      key &&= key.lstrip[0,1].downcase
      if cmd = COMMANDS[key]
        command = Array(cmd) + args
        warn "#{$0}: Sending #{command.inspect} command..."
        @driver.send command
        break if cmd == :quit
      else # invalid command
        COMMANDS.each do |key, cmd|
          desc = Array(cmd).first.to_s.tr('_', ' ')
          warn "#{$0}: Type #{key} then ENTER to #{desc}."
        end
      end
    end
  ensure
    # manually kill tork-server(1) because it will continue blocking for more
    # user input (even though the interaction loop above has been terminated)
    Process.kill :SIGTERM, input.pid if input
  end
end

Process.waitall
