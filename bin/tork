#!/usr/bin/env ruby
=begin =======================================================================

# TORK 1 2012-10-10 18.2.4

## NAME

tork - Continuous testing tool for Ruby

## SYNOPSIS

`tork` [*OPTION*]... [*CONFIG*]...

## DESCRIPTION

This program is a simple command-line user interface for tork-driver(1).  It
loads the given *CONFIG* files (which are either paths to actual files or
names of helper libraries in the tork/config/ namespace of Ruby's load path)
and then waits for you to supply interactive commands either {1} directly on
its stdin or {2} remotely through tork-writer(1).  From then onward, you may
press the ENTER key (supplying no command) to see a menu of accepted commands.

Some interactive commands accept additional arguments, as described below.

`t` *test_file* [*line_number*]...
  Runs the given *test_file* while only running those tests that are defined
  on the given list of *line_number*s.  If no *line_number*s are given, then
  only those tests that have changed since the last run of the *test_file*
  will now be run.

`s` [*signal*]
  Stops any test files that are currently running by sending the given
  *signal* (default `SIGTERM`) to their respective worker processes.

If available, rlwrap(1) will enhance interactivity by providing line editing,
command history, and filename completion among other readline(3) features.

## OPTIONS

`-h`, `--help`
  Show this help manual.

## SEE ALSO

tork(1), tork-driver(1), tork-master(1), tork-herald(1), tork-writer(1),
rlwrap(1)

=end =========================================================================

$0 = File.basename(__FILE__) # for easier identification in ps(1) output

require 'binman'
BinMan.help

require 'json'
ENV['TORK_CONFIGS'] = JSON.dump(ARGV)

#-----------------------------------------------------------------------------
# backend
#-----------------------------------------------------------------------------

require 'tork/client'

warn "#{$0}: Absorbing test execution overhead..."
@driver = Tork::Client::Transceiver.new('tork-driver') do |event, *details|
  case event_sym = event.to_sym
  when :load then warn "#{$0}: Overhead absorbed. Ready for testing!"
  when :over then warn "#{$0}: Reabsorbing changed overhead files..."
  else
    test_file, line_numbers, log_file, worker_number, exit_status = details
    message = [event.upcase, [test_file, *line_numbers].join(':'),
               exit_status].compact.join(' ')

    color = case event_sym
            when :pass then "\e[34m%s\e[0m" # blue
            when :fail then "\e[31m%s\e[0m" # red
            end
    message = color % message if color and STDOUT.tty?
    message = [message, File.read(log_file), message] if event_sym == :fail

    puts message
  end
end

class << @driver
  def send command
    warn "#{$0}: Sending #{command.inspect} command..."
    super
  end

  def quit
    send [:quit]
    super
  end
end

at_exit do
  @driver.quit
  Process.waitall
end

#-----------------------------------------------------------------------------
# frontend
#-----------------------------------------------------------------------------

COMMANDS = {
  't' => :run_test_file,
  'a' => :run_all_test_files,
  's' => :stop_running_test_files,
  'k' => [:stop_running_test_files, :SIGKILL],
  'p' => :rerun_passed_test_files,
  'f' => :rerun_failed_test_files,
  'o' => :reabsorb_overhead_files,
  'q' => :quit,
}

wrapper = 'tork-reader'
wrapper = "rlwrap -c #{wrapper}" if system 'which rlwrap >/dev/null 2>&1'
IO.popen(wrapper) do |input|
  # user has chosen to quit by pressing Control-D
  # which automatically terminates tork-reader(1)
  # so we have to detect this and exit ourselves!
  Thread.new { Process.waitpid(input.pid); exit }

  begin
    while line = input.gets
      key, *args = line.split
      key &&= key.lstrip[0,1].downcase
      if cmd = COMMANDS[key]
        exit if cmd == :quit
        @driver.send Array(cmd) + args
      else # invalid command
        COMMANDS.each do |key, cmd|
          desc = Array(cmd).first.to_s.tr('_', ' ')
          warn "#{$0}: Type #{key} then ENTER to #{desc}."
        end
      end
    end
  ensure
    # user has chosen to quit by entering the quit command
    # which will NOT automatically terminate tork-reader(1)
    # so we have to kill it here, before exiting ourselves!
    Process.kill :SIGTERM, input.pid
  end
end
