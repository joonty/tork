#!/usr/bin/env ruby
=begin =======================================================================

# TORK 1 2012-10-10 18.2.4

## NAME

tork - Continuous testing tool for Ruby

## SYNOPSIS

`tork` [*OPTION*]... [*CONFIG*]...

## DESCRIPTION

This program is a simple command-line user interface for tork-driver(1).

First, it applies the given *CONFIG* values, which are either (1) paths to
directories that contain configuration files or (2) names of configuration
helpers listed in the description of the `TORK_CONFIGS` environment variable.

Next, it waits for you to supply interactive commands either (1) directly on
its stdin or (2) remotely through tork-remote(1).  From then onward, you may
press the ENTER key (supplying no command) to see a menu of accepted commands.

Some interactive commands accept additional arguments, described as follows.

`t` *test_file* [*line_number*]...
  Runs the given *test_file* while only running those tests that are defined
  on the given list of *line_number*s.  If no *line_number*s are given, then
  only those tests that have changed since the last run of the *test_file*
  will now be run.

`s` [*signal*]
  Stops test files that are currently running by sending the given *signal*
  (optional; defaults to `SIGTERM`) to their respective worker processes.

## OPTIONS

`-h`, `--help`
  Show this help manual.

## FILES

See tork-driver(1) and tork-master(1).

## ENVIRONMENT

`TORK_CONFIGS`
  Colon-separated (:) list of either paths to directories that contain
  configuration files or names of the following configuration helpers:

  > `dotlog`
  >   Hides log files by prefixing their names with a period (dot).
  >
  > `logdir`
  >   Keeps log files away from your tests, in the `log/` directory.
  >
  > `coverage`
  >   Measures C0 code coverage under Ruby 1.9 and dumps a hash in YAML
  >   format at the end of your log file containing every Ruby script that
  >   was loaded from the current working directory or any of its descendant
  >   directories (the key) mapped to the following information (the value):
  >
  > > `:grade`
  > >   Percentage of source lines that were C0 covered.
  > >
  > > `:nsloc`
  > >   Total number of source lines of code in the file.
  > >
  > > `:holes`
  > >   Line numbers of source lines that were not covered.
  >
  > `xunit`
  >   Supports the Test::Unit standard library.
  >
  > `rspec`
  >   Supports the [RSpec] testing framework.
  >
  > `cucumber`
  >   Supports the [Cucumber] testing framework.
  >
  > `rails`
  >   Supports the [Ruby on Rails] web framework.
  >
  > `factory_girl`
  >   Supports the [factory_girl] testing library.
  >
  > `parallel_tests`
  >   Supports the [parallel_tests] testing library.

## SEE ALSO

tork(1), tork-driver(1), tork-master(1)

[factory_girl]: https://github.com/thoughtbot/factory_girl
[memory_test_fix]: https://github.com/stepahn/memory_test_fix
[parallel_tests]: https://github.com/grosser/parallel_tests
[Ruby on Rails]: http://rubyonrails.org
[Cucumber]: https://cukes.info
[RSpec]: http://rspec.info

=end =========================================================================

$0 = File.basename(__FILE__) # for easier identification in ps(1) output

require 'binman'
BinMan.help

ENV['TORK_CONFIGS'] = [ENV['TORK_CONFIGS'], *ARGV].join(':')

#-----------------------------------------------------------------------------
# backend
#-----------------------------------------------------------------------------

require 'tork/client'

warn "#{$0}: Absorbing test execution overhead..."
@driver = Tork::Client::Transceiver.new('tork-driver') do |event, *details|
  case event_sym = event.to_sym
  when :absorb   then warn "#{$0}: Overhead absorbed. Ready for testing!"
  when :reabsorb then warn "#{$0}: Reabsorbing changed overhead files..."
  when :test, :pass, :fail
    test_file, line_numbers, log_file, worker_number, exit_status = details
    message = [event.upcase, [test_file, *line_numbers].join(':'),
               exit_status].compact.join(' ')

    color = case event_sym
            when :pass then "\e[34m%s\e[0m" # blue
            when :fail then "\e[31m%s\e[0m" # red
            end
    message = color % message if color and STDOUT.tty?
    message = [message, File.read(log_file), message] if event_sym == :fail

    puts message
  end
end

class << @driver
  def send command
    warn "#{$0}: Sending #{command.inspect} command..."
    super
  end

  def quit
    send [:quit]
    super
  end
end

at_exit do
  @driver.quit
  Process.waitall
end

#-----------------------------------------------------------------------------
# frontend
#-----------------------------------------------------------------------------

COMMANDS = {
  't' => :run_test_file,
  'a' => :run_all_test_files,
  's' => :stop_running_test_files,
  'k' => [:stop_running_test_files, :SIGKILL],
  'p' => :rerun_passed_test_files,
  'f' => :rerun_failed_test_files,
  'o' => :reabsorb_overhead,
  'q' => :quit,
}

while line = STDIN.gets
  key, *args = line.split
  key &&= key.lstrip[0,1].downcase
  if cmd = COMMANDS[key]
    exit if cmd == :quit
    @driver.send Array(cmd) + args
  else # invalid command
    COMMANDS.each do |key, cmd|
      desc = Array(cmd).first.to_s.tr('_', ' ')
      warn "#{$0}: Type #{key} then ENTER to #{desc}."
    end
  end
end
